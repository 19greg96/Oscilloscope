

#include "BSP_ADC.h"

static inline void stopConversion(ADC_HandleTypeDef* AdcHandle) {
	if (HAL_ADC_Stop_DMA(&hadc1) != HAL_OK) { // stops DMA immediately
		Error_Handler();
	}
	if (HAL_ADC_Stop_DMA(&hadc2) != HAL_OK) { // stops DMA immediately
		Error_Handler();
	}
	ADC_conversionEnd = 1;
}

static inline void processBuffer(uint32_t buffStart) {
	uint32_t last;
	uint32_t curr;
	
	if (ADC_oversampling == 0) { // split logic for faster ISR
		if (ADC_bufferInitialized && triggerMode == SCOPE_TRIGGER_DISABLE) { // this is here and not in loop for faster ISR
			ADC_triggered = 1;
			ADC_Oversampled_triggered_at = buffStart;
		}
		
		last = g_ADCBuffer1[(buffStart - 1) & ADC_INPUT_BUFFER_MASK];
		for (uint32_t i = buffStart; i < (buffStart + ADC_INPUT_BUFFER_SIZE / 2); i ++) {
			curr = g_ADCBuffer1[i];
			g_ADCOversampledBuffer1[i] = curr;
			if (!ADC_triggered && ADC_bufferInitialized) {
				if (triggerEdge == SCOPE_TRIGGER_EDGE_RISING) {
					if (last < SCOPE_triggerLevel && curr >= SCOPE_triggerLevel) {
						// TODO: implement hysteresis trigger to prevent trigger caused by noise on flat signals
						ADC_triggered = 1;
						ADC_Oversampled_triggered_at = i;
						// break;
					}
				} else if (triggerEdge == SCOPE_TRIGGER_EDGE_FALLING) {
					if (last > SCOPE_triggerLevel && curr <= SCOPE_triggerLevel) {
						ADC_triggered = 1;
						ADC_Oversampled_triggered_at = i;
						// break;
					}
				}
			}
			last = curr;
		}
	} else {
		uint32_t avg_step = (1 << (ADC_oversampling)); // when to avarage.
		
		g_ADCOversampledBuffer1[ADC_oversampledBufferWritePos] = 0;
		ADC_nSamplesAtCurrPos = 0;
		
		if (ADC_bufferInitialized && triggerMode == SCOPE_TRIGGER_DISABLE) { // this is here and not in loop for faster ISR
			ADC_triggered = 1;
			ADC_Oversampled_triggered_at = ADC_oversampledBufferWritePos;
		}
		
		for (uint32_t i = buffStart; i < (buffStart + ADC_INPUT_BUFFER_SIZE / 2); i ++) {
			if (ADC_nSamplesAtCurrPos == avg_step) {
				if (!ADC_triggered && ADC_bufferInitialized) {
					last = g_ADCOversampledBuffer1[(ADC_oversampledBufferWritePos - 1) & ADC_INPUT_BUFFER_MASK];
					curr = g_ADCOversampledBuffer1[ADC_oversampledBufferWritePos]; //  & ADC_INPUT_BUFFER_MASK
					if (triggerEdge == SCOPE_TRIGGER_EDGE_RISING) {
						if (last < SCOPE_triggerLevel && curr >= SCOPE_triggerLevel) {
							// TODO: implement hysteresis trigger to prevent trigger caused by noise on flat signals
							ADC_triggered = 1;
							ADC_Oversampled_triggered_at = ADC_oversampledBufferWritePos;
						}
					} else if (triggerEdge == SCOPE_TRIGGER_EDGE_FALLING) {
						if (last > SCOPE_triggerLevel && curr <= SCOPE_triggerLevel) {
							ADC_triggered = 1;
							ADC_Oversampled_triggered_at = ADC_oversampledBufferWritePos;
						}
					}
				}
				
				ADC_oversampledBufferWritePos = (ADC_oversampledBufferWritePos + 1) & ADC_INPUT_BUFFER_MASK;
				g_ADCOversampledBuffer1[ADC_oversampledBufferWritePos] = 0;
				ADC_nSamplesAtCurrPos = 0;
			}
			g_ADCOversampledBuffer1[ADC_oversampledBufferWritePos] += g_ADCBuffer1[i]; // & ADC_INPUT_BUFFER_MASK
			ADC_nSamplesAtCurrPos++;
		}
	}
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle) {
	if (ADC_triggered) { // trigger occured in HAL_ADC_ConvHalfCpltCallback
		if (ADC_oversampling == 0) {
			stopConversion(AdcHandle);
			for (uint32_t i = ADC_INPUT_BUFFER_SIZE / 2; i < ADC_INPUT_BUFFER_SIZE; i ++) {
				g_ADCOversampledBuffer1[i] = g_ADCBuffer1[i];
			}
			return;
		} else if (ADC_oversampledBufferWritePos - ADC_Oversampled_triggered_at >= (ADC_INPUT_BUFFER_SIZE / 4)) {
			stopConversion(AdcHandle);
			return;
		}
	}
	
	processBuffer(ADC_INPUT_BUFFER_SIZE / 2);
	
	/*
	if (ADC_triggered && (ADC_Oversampled_triggered_at < (ADC_INPUT_BUFFER_SIZE * 3 / 4))) { // triggered before last quarter
		stopConversion(AdcHandle);
	}*/
	if (ADC_triggered) { // triggered before last quarter
		if (ADC_oversampling == 0) {
			if (ADC_Oversampled_triggered_at < (ADC_INPUT_BUFFER_SIZE * 3 / 4)) {
				stopConversion(AdcHandle);
			}
		} else if (ADC_oversampledBufferWritePos - ADC_Oversampled_triggered_at >= (ADC_INPUT_BUFFER_SIZE / 4)) {
			stopConversion(AdcHandle);
		}
	}
}

void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* AdcHandle) {
	if (ADC_triggered) { // trigger occured in HAL_ADC_ConvCpltCallback
		if (ADC_oversampling == 0) {
			stopConversion(AdcHandle);
			for (uint32_t i = 0; i < ADC_INPUT_BUFFER_SIZE / 2; i ++) {
				g_ADCOversampledBuffer1[i] = g_ADCBuffer1[i];
			}
			return;
		} else if (ADC_oversampledBufferWritePos - ADC_Oversampled_triggered_at >= (ADC_INPUT_BUFFER_SIZE / 4)) {
			stopConversion(AdcHandle);
			return;
		}
	}
	
	processBuffer(0);
	
	if (ADC_triggered) {
		if (ADC_oversampling == 0) {
			if ((ADC_Oversampled_triggered_at < (ADC_INPUT_BUFFER_SIZE / 4)) || (ADC_Oversampled_triggered_at > (ADC_INPUT_BUFFER_SIZE / 2))) {
				stopConversion(AdcHandle);
			}
		} else if (ADC_oversampledBufferWritePos - ADC_Oversampled_triggered_at >= (ADC_INPUT_BUFFER_SIZE / 4)) {
			stopConversion(AdcHandle);
		}
	}
	
	if (ADC_bufferInitialized == 0) {
		// don't check first half of buffer for trigger event, because if it occured in first quarter,
		// we wouldn't have a full useable half buffer of data available. We only need to do this if
		// trigger event occured in first quarter, but logic for that would be more complicated.
		if (ADC_oversampling == 0) {
			ADC_bufferInitialized = 1;
		} else if (ADC_oversampledBufferWritePos > ADC_INPUT_BUFFER_SIZE / 4) {
			ADC_bufferInitialized = 1;
		}
	}
	/*
	if (ADC_triggered && ((ADC_Oversampled_triggered_at < (ADC_INPUT_BUFFER_SIZE / 4)) || (ADC_Oversampled_triggered_at > (ADC_INPUT_BUFFER_SIZE / 2)))) {
		stopConversion(AdcHandle);
	}
	*/
}

void HAL_ADC_ErrorCallback(ADC_HandleTypeDef* AdcHandle) {
	Error_Handler();
}


void ADC_IRQHandler() {
	HAL_ADC_IRQHandler(&hadc1);
	HAL_ADC_IRQHandler(&hadc2);
}

void DMA2_Stream0_IRQHandler() {
	HAL_DMA_IRQHandler(&hdma2adc1);
}
void DMA2_Stream2_IRQHandler() {
	HAL_DMA_IRQHandler(&hdma2adc2);
}

void SCOPE_enableTrigger() {
	if (hadc1.DMA_Handle->State == HAL_DMA_STATE_BUSY) {
		if (HAL_ADC_Stop_DMA(&hadc1) != HAL_OK) { // stops DMA immediately
			Error_Handler();
		}
	}
	if (hadc2.DMA_Handle->State == HAL_DMA_STATE_BUSY) {
		if (HAL_ADC_Stop_DMA(&hadc2) != HAL_OK) { // stops DMA immediately
			Error_Handler();
		}
	}
	ADC_triggered = 0;
	ADC_bufferInitialized = 0;
	
	ADC_oversampledBufferWritePos = 0;
	ADC_nSamplesAtCurrPos = 0;
	if (HAL_ADC_Start_DMA(&hadc1, g_ADCBuffer1, ADC_INPUT_BUFFER_SIZE) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_ADC_Start_DMA(&hadc2, g_ADCBuffer2, ADC_INPUT_BUFFER_SIZE) != HAL_OK) {
		Error_Handler();
	}
}

void ADC_Init() {
	ADC_conversionEnd = 0;
	ADC_Oversampled_triggered_at = 0;
	
	triggerSource = SCOPE_TRIGGER_SOURCE_CH1;
	triggerEdge = SCOPE_TRIGGER_EDGE_RISING; // SCOPE_TRIGGER_FALLING
	
	triggerMode = SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_DISABLE SCOPE_TRIGGER_SINGLE 
	ADC_oversampling = 0;
	SCOPE_triggerLevel = 4 << ADC_oversampling; //1924; // half of DAC generated value
	
	// triggerMode = SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_DISABLE SCOPE_TRIGGER_SINGLE 
	// ADC_oversampling = 1;
	// SCOPE_triggerLevel = 30 << ADC_oversampling; //1924; // half of DAC generated value
	
	// triggerMode = SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_DISABLE SCOPE_TRIGGER_SINGLE 
	// ADC_oversampling = 4;
	// SCOPE_triggerLevel = 30 << ADC_oversampling; //1924; // half of DAC generated value
	
	// triggerMode = SCOPE_TRIGGER_DISABLE; // SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_DISABLE SCOPE_TRIGGER_SINGLE 
	// triggerEdge = SCOPE_TRIGGER_EDGE_DISABLED;
	// ADC_oversampling = 0;
	// SCOPE_triggerLevel = 30 << ADC_oversampling; //1924; // half of DAC generated value
	
	// triggerMode = SCOPE_TRIGGER_DISABLE; // SCOPE_TRIGGER_CONTINUOUS; // SCOPE_TRIGGER_DISABLE SCOPE_TRIGGER_SINGLE 
	// triggerEdge = SCOPE_TRIGGER_EDGE_DISABLED;
	// ADC_oversampling = 1;
	// SCOPE_triggerLevel = 30 << ADC_oversampling; //1924; // half of DAC generated value
	
	
	MX_ADC1_Init();
	MX_ADC2_Init();
	
	HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(ADC_IRQn);
	
	
	SCOPE_enableTrigger();
}


/**
* @brief ADC MSP Initialization
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc) {

	GPIO_InitTypeDef GPIO_InitStruct = {0};
	if(hadc->Instance==ADC1) {
	/* USER CODE BEGIN ADC1_MspInit 0 */

	/* USER CODE END ADC1_MspInit 0 */
		/* Peripheral clock enable */
		__HAL_RCC_ADC1_CLK_ENABLE();
	
		__HAL_RCC_GPIOA_CLK_ENABLE();
		/**ADC1 GPIO Configuration		
		PA0-WKUP		 ------> ADC1_IN0 
		*/
		GPIO_InitStruct.Pin = ADC_IN1_Pin;
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
		GPIO_InitStruct.Pull = GPIO_NOPULL;
		HAL_GPIO_Init(ADC_IN1_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN ADC1_MspInit 1 */
		
	/* USER CODE END ADC1_MspInit 1 */
	}
	else if(hadc->Instance==ADC2) {
	/* USER CODE BEGIN ADC2_MspInit 0 */

	/* USER CODE END ADC2_MspInit 0 */
		/* Peripheral clock enable */
		__HAL_RCC_ADC2_CLK_ENABLE();
	
		__HAL_RCC_GPIOA_CLK_ENABLE();
		/**ADC2 GPIO Configuration		
		PA1		 ------> ADC2_IN1 
		*/
		GPIO_InitStruct.Pin = ADC_IN2_Pin;
		GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
		GPIO_InitStruct.Pull = GPIO_NOPULL;
		HAL_GPIO_Init(ADC_IN2_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN ADC2_MspInit 1 */
		
	/* USER CODE END ADC2_MspInit 1 */
	}

}

/**
* @brief ADC MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc) {

	if(hadc->Instance==ADC1) {
	/* USER CODE BEGIN ADC1_MspDeInit 0 */

	/* USER CODE END ADC1_MspDeInit 0 */
		/* Peripheral clock disable */
		__HAL_RCC_ADC1_CLK_DISABLE();
	
		/**ADC1 GPIO Configuration		
		PA0-WKUP		 ------> ADC1_IN0 
		*/
		HAL_GPIO_DeInit(ADC_IN1_GPIO_Port, ADC_IN1_Pin);

	/* USER CODE BEGIN ADC1_MspDeInit 1 */

	/* USER CODE END ADC1_MspDeInit 1 */
	}
	else if(hadc->Instance==ADC2) {
	/* USER CODE BEGIN ADC2_MspDeInit 0 */

	/* USER CODE END ADC2_MspDeInit 0 */
		/* Peripheral clock disable */
		__HAL_RCC_ADC2_CLK_DISABLE();
	
		/**ADC2 GPIO Configuration		
		PA1		 ------> ADC2_IN1 
		*/
		HAL_GPIO_DeInit(ADC_IN2_GPIO_Port, ADC_IN2_Pin);

	/* USER CODE BEGIN ADC2_MspDeInit 1 */

	/* USER CODE END ADC2_MspDeInit 1 */
	}

}


/**
	* @brief ADC1 Initialization Function
	* @param None
	* @retval None
	*/
static void MX_ADC1_Init(void) {

	/* USER CODE BEGIN ADC1_Init 0 */

	/* USER CODE END ADC1_Init 0 */

	ADC_ChannelConfTypeDef sConfig = {0};
	// ADC_AnalogWDGConfTypeDef sAWDConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */
	/**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
	*/
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4; // 90MHz / 4 = Fadc = 22.5MHz
	hadc1.Init.Resolution = ADC_RESOLUTION_6B; // Tconv = SamplingTime + Resolution [1/Fadc]
	hadc1.Init.ScanConvMode = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.NbrOfConversion = 1;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.EOCSelection = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
		Error_Handler();
	}
	
	/**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. */
	/*
	
	SampleTime:
	ADC_SAMPLETIME_3CYCLES
	ADC_SAMPLETIME_15CYCLES
	ADC_SAMPLETIME_28CYCLES
	ADC_SAMPLETIME_56CYCLES
	ADC_SAMPLETIME_84CYCLES
	ADC_SAMPLETIME_112CYCLES
	ADC_SAMPLETIME_144CYCLES
	ADC_SAMPLETIME_480CYCLES
	
	Prescaler:
	ADC_CLOCK_SYNC_PCLK_DIV4
	ADC_CLOCK_SYNC_PCLK_DIV6
	ADC_CLOCK_SYNC_PCLK_DIV8
	
	Resolution:
	ADC_RESOLUTION_12B
	ADC_RESOLUTION_10B
	ADC_RESOLUTION_8B
	ADC_RESOLUTION_6B
	
	
	Fadc = 90MHz / Prescaler = 22.5MHz
	
	
	Tconv = SampleTime + Resolution [1/Fadc]
	Fconv = Fadc / (SampleTime + Resolution)
	
	*/
	
	sConfig.Channel = ADC_CHANNEL_0;
	sConfig.Rank = 1;
	sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES; // 480, 28, 3
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	
	// sAWDConfig.Channel = ADC_CHANNEL_0;
	// sAWDConfig.HighThreshold = SCOPE_triggerLevel;
	// sAWDConfig.LowThreshold = 0;
	// sAWDConfig.ITMode = ENABLE;
	// sAWDConfig.WatchdogMode = ADC_ANALOGWATCHDOG_ALL_REG;
	// if (HAL_ADC_AnalogWDGConfig(&hadc1, &sAWDConfig) != HAL_OK) {
		// Error_Handler();
	// }
	/* USER CODE BEGIN ADC1_Init 2 */
	/* USER CODE END ADC1_Init 2 */

	// RM0390
	// https://www.st.com/content/ccc/resource/technical/document/reference_manual/4d/ed/bc/89/b5/70/40/dc/DM00135183.pdf/files/DM00135183.pdf/jcr:content/translations/en.DM00135183.pdf
	__DMA2_CLK_ENABLE(); 
	hdma2adc1.Instance = DMA2_Stream0;
  
	hdma2adc1.Init.Channel  = DMA_CHANNEL_0;
	hdma2adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
	hdma2adc1.Init.PeriphInc = DMA_PINC_DISABLE;
	hdma2adc1.Init.MemInc = DMA_MINC_ENABLE;
	hdma2adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
	hdma2adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
	hdma2adc1.Init.Mode = DMA_CIRCULAR;
	hdma2adc1.Init.Priority = DMA_PRIORITY_HIGH;
	hdma2adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
	hdma2adc1.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
	hdma2adc1.Init.MemBurst = DMA_MBURST_SINGLE;
	hdma2adc1.Init.PeriphBurst = DMA_PBURST_SINGLE; 
	
	if (HAL_DMA_Init(&hdma2adc1) != HAL_OK) {
		Error_Handler();
	}
	
	__HAL_LINKDMA(&hadc1, DMA_Handle, hdma2adc1);
 
	HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);   
	HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
}

/**
	* @brief ADC2 Initialization Function
	* @param None
	* @retval None
	*/
static void MX_ADC2_Init(void) {

	/* USER CODE BEGIN ADC2_Init 0 */

	/* USER CODE END ADC2_Init 0 */

	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC2_Init 1 */

	/* USER CODE END ADC2_Init 1 */
	/**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
	*/
	hadc2.Instance = ADC2;
	hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc2.Init.Resolution = ADC_RESOLUTION_6B;
	hadc2.Init.ScanConvMode = DISABLE;
	hadc2.Init.ContinuousConvMode = ENABLE;
	hadc2.Init.DiscontinuousConvMode = DISABLE;
	hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc2.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1;
	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc2.Init.NbrOfConversion = 1;
	hadc2.Init.DMAContinuousRequests = ENABLE;
	hadc2.Init.EOCSelection = DISABLE;
	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
		Error_Handler();
	}
	/**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
	*/
	sConfig.Channel = ADC_CHANNEL_1;
	sConfig.Rank = 1;
	sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC2_Init 2 */
	
	// RM0390
	// https://www.st.com/content/ccc/resource/technical/document/reference_manual/4d/ed/bc/89/b5/70/40/dc/DM00135183.pdf/files/DM00135183.pdf/jcr:content/translations/en.DM00135183.pdf
	__DMA2_CLK_ENABLE(); 
	hdma2adc2.Instance = DMA2_Stream2;
  
	hdma2adc2.Init.Channel  = DMA_CHANNEL_1;
	hdma2adc2.Init.Direction = DMA_PERIPH_TO_MEMORY;
	hdma2adc2.Init.PeriphInc = DMA_PINC_DISABLE;
	hdma2adc2.Init.MemInc = DMA_MINC_ENABLE;
	hdma2adc2.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
	hdma2adc2.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
	hdma2adc2.Init.Mode = DMA_CIRCULAR;
	hdma2adc2.Init.Priority = DMA_PRIORITY_HIGH;
	hdma2adc2.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
	hdma2adc2.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
	hdma2adc2.Init.MemBurst = DMA_MBURST_SINGLE;
	hdma2adc2.Init.PeriphBurst = DMA_PBURST_SINGLE;
	
	if (HAL_DMA_Init(&hdma2adc2) != HAL_OK) {
		Error_Handler();
	}
	
	__HAL_LINKDMA(&hadc2, DMA_Handle, hdma2adc2);
 
	HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);   
	HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
	
	/* USER CODE END ADC2_Init 2 */

}








